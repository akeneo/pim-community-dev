<?php

namespace Pim\Bundle\CatalogBundle\Doctrine\MongoDBODM;

use Pim\Bundle\CatalogBundle\Doctrine\CompletenessGeneratorInterface;
use Pim\Bundle\CatalogBundle\Entity\Channel;
use Pim\Bundle\CatalogBundle\Entity\Locale;
use Pim\Bundle\CatalogBundle\Entity\AttributeRequirement;
use Pim\Bundle\CatalogBundle\Model\ProductInterface;
use Pim\Bundle\CatalogBundle\Model\ProductValueInterface;
use Pim\Bundle\CatalogBundle\Model\Completeness;
use Pim\Bundle\CatalogBundle\Factory\CompletenessFactory;
use Doctrine\Common\Collections\ArrayCollection;
use Symfony\Bridge\Doctrine\ManagerRegistry;
use Doctrine\ODM\MongoDB\DocumentManager;

/**
 * Generate the completeness when Product are in MongoDBODM
 * storage. Please note that the generation for several products
 * is done on the MongoDB via a JS generated by the application via HTTP.
 *
 * This generator is only able to generate completeness for one product
 *
 * @author    Benoit Jacquemont <benoit@akeneo.com>
 * @copyright 2013 Akeneo SAS (http://www.akeneo.com)
 * @license   http://opensource.org/licenses/osl-3.0.php  Open Software License (OSL 3.0)
 */
class CompletenessGenerator implements CompletenessGeneratorInterface
{
    /**
     * @var DocumentManager;
     */
    protected $documentManager;

    /**
     * @var CompletenessFactory
     */
    protected $completenessFactory;

    /**
     * Constructor
     *
     * @param DocumentManager $documentManager
     */
    public function __construct(DocumentManager $documentManager, CompletenessFactory $completenessFactory)
    {
        $this->documentManager = $documentManager;
        $this->completenessFactory = $completenessFactory;
    }

    /**
     * {@inheritdoc}
     */
    public function generateProductCompletenesses(ProductInterface $product)
    {
        $completenesses = $this->buildProductCompletenesses($product);

        $product->setCompletenesses(new ArrayCollection($completenesses));

        $this->documentManager->flush($product);
    }

    /**
     * Build the completeness for the product
     *
     * @param ProductInterface $product
     *
     * @return array
     */
    public function buildProductCompletenesses(ProductInterface $product)
    {
        $completenesses = array();

        $stats = $this->collectStats($product);

        foreach ($stats as $channelStats) {
            $channel = $channelStats['object'];
            $channelData = $channelStats['data'];

            foreach ($channelData as $localeStats) {
                $locale = $localeStats['object'];
                $localeData = $localeStats['data'];

                $completeness = $this->completenessFactory->build(
                    $channel,
                    $locale,
                    $localeData['missing_count'],
                    $localeData['required_count']
                );

                $completenesses[] = $completeness;
            }
        }

        return $completenesses;
    }

    /**
     * Generate statistics on the product completeness
     *
     * @param ProductInterface $product
     * @param ArrayCollection  $attributeRequirements
     *
     * @return array $stats
     */
    protected function collectStats(ProductInterface $product)
    {
        $stats = array();

        $requirements = $product->getFamily()->getAttributeRequirements();

        foreach ($requirements as $req) {
            $channel = $req->getChannel()->getCode();
            $locales = $req->getChannel()->getLocales();

            if (!isset($stats[$channel])) {
                $stats[$channel]['object'] = $req->getChannel();
                $stats[$channel]['data'] = array();
            }

            foreach ($locales as $localeObject) {
                $locale = $localeObject->getCode();
                if (!isset($stats[$channel]['data'][$locale])) {
                    $stats[$channel]['data'][$locale] = array();
                    $stats[$channel]['data'][$locale]['object'] = $localeObject;
                    $stats[$channel]['data'][$locale]['data'] = array();
                    $stats[$channel]['data'][$locale]['data']['missing_count'] = 0;
                    $stats[$channel]['data'][$locale]['data']['required_count'] = 0;
                }

                $stats[$channel]['data'][$locale]['data']['required_count']++;

                $value = $product->getValue($req->getAttribute()->getCode(), $locale, $channel);

                if ($this->isValueMissing($req, $value)) {
                    $stats[$channel]['data'][$locale]['data']['missing_count'] ++;
                }
            }
        }

        return $stats;
    }

    /**
     * Apply rules defining if a value is missing.
     *
     * @param AbstractAttribute $attribute
     *
     * @return boolean $valueMissing
     */
    protected function isValueMissing(
        AttributeRequirement $req,
        ProductValueInterface $value = null
    ) {
        $valueMissing = false;
        $attribute = $req->getAttribute();

        if ($attribute->getBackendType() === "prices") {

            if (!$this->isPriceComplete($value, $req->getChannel())) {
                $valueMissing = true;
            }

        } elseif (($value === null) ||
            ($value->getData() === null) ||
            (is_array($value->getData()) && count($value->getData()) === 0)) {

            $valueMissing = true;
        }

        return $valueMissing;
    }

    /**
     * Determine if the value price provided is complete, i.e. a price
     * exists for all currencies provided
     *
     * @param ProductValueInterface $value
     * @param Channel               $channel
     *
     * @return boolean
     */
    protected function isPriceComplete(ProductValueInterface $value, Channel $channel)
    {
        $completePrice = true;
        $currencies = $channel->getCurrencies();

        foreach ($currencies as $currency) {
            $priceFound = false;

            foreach ($value->getPrices() as $price) {

                if (($price->getCurrency()->getCode() === $currency->getCode())&&
                    ($price->getData() !== null)) {
                    $priceFound = true;
                }
            }
            if (!$priceFound) {
                $completePrice = false;
            }
        }

        return $completePrice;
    }

    /**
     * {@inheritdoc}
     */
    public function generate(array $criteria = array(), $limit = null)
    {
        // @TODO Not implemented yet
        return;
    }

    /**
     * {@inheritdoc}
     */
    public function schedule(ProductInterface $product)
    {
        $product->setCompletenesses(new ArrayCollection());

        $this->documentManager->flush($product);
    }
}
