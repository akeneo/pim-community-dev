#!/usr/bin/env node

const fs = require('fs');
const yargs = require('yargs');
const glob = require('glob');

const {_ : commandName, ComponentName, sourceFolder} = yargs
  .command('generate [ComponentName]', 'Generate a new component with the given name', yargs => {
    yargs.positional('ComponentName', {
      describe: 'The component name you want to create',
      require: true,
    });
  })
  .check((argv, options) => {
    switch (argv._[0]) {
      case 'metric':
        if (undefined === argv.sourceFolder) {
          throw new Error('The source folder argument is required');
        }
        if (!fs.existsSync(argv.sourceFolder)) {
          throw new Error(`Source folder "${argv.sourceFolder}" does not exist`);
        }
        break;
      case 'generate':
        if (undefined === argv.ComponentName) {
          throw new Error('The component name argument is required');
        }
        if (argv.ComponentName[0] !== argv.ComponentName[0].toUpperCase()) {
          throw new Error('The component name should be Capitalized (first letter uppercase)');
        }

        if (fs.existsSync(`src/components/${argv.ComponentName}`)) {
          throw new Error(`Component "${argv.ComponentName}" already exists`);
        }
        break;
      default:
        break;
    }

    return true;
  })
  .command('metric [sourceFolder]', 'Display metric about DSM usage', yargs => {
    yargs.positional('sourceFolder', {
      describe: 'The folder to audit',
      require: true,
    });
  })
  .help('h')
  .alias('h', 'help')
  .demandCommand(2).argv;

/**
 * Copy Component files
 */
const copyComponentFolder = async (source, target) => {
  const dummyComponentName = source.split('/').pop();
  const targetComponentName = target.split('/').pop();

  fs.mkdirSync(target);
  const files = fs.readdirSync(source);
  await Promise.all(
    files.map(
      filePath =>
        new Promise(resolve => {
          const writeStream = fs.createWriteStream(
            `${target}/${filePath.replace(dummyComponentName, targetComponentName)}`
          );
          writeStream.on('finish', resolve);
          fs.createReadStream(`${source}/${filePath}`).pipe(writeStream);
        })
    )
  );
};

/**
 * Search and replace in Component files
 */
const replaceInFile = async (file, search, replace) => {
  return new Promise((resolve, reject) => {
    fs.readFile(file, (err, data) => {
      if (err) {
        reject(err);
      } else {
        const replacedData = data
          .toString('utf8')
          .replace(new RegExp(search, 'g'), replace)
          .replace(new RegExp(search.toLowerCase(), 'g'), replace.toLowerCase());

        fs.writeFileSync(file, replacedData);
        resolve();
      }
    });
  });
};
const renameComponentFolder = async (sourceComponentName, targetComponentName) => {
  const files = fs.readdirSync(`src/components/${targetComponentName}`);
  for (const iterator of files) {
    await replaceInFile(`src/components/${targetComponentName}/${iterator}`, sourceComponentName, targetComponentName);
  }
};

/**
 * Add component to export
 */
const exportComponentToIndex = async (path, componentName) => {
  fs.appendFileSync(path, `export * from './${componentName}/${componentName}';\n`);
};

const getTsxFiles = async (sourceFolder) => {
  return new Promise((resolve, reject) => {
    glob(`${sourceFolder}/**/*.tsx`, async (error, files) => {
      if (null !== error) {reject(error); return;}

      resolve(files);
    })
  });
}

/**
 * Get file metrics regarding dsm usage
 */
const getFileMetrics = async (filePath) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, (err, data) => {
      if (err) {
        reject(err);
      } else {
        const fileContent = data
          .toString('utf8');

        const isSVG = -1 !== fileContent.indexOf(`<svg `);
        const isTest = -1 !== fileContent.indexOf(`from '@testing-library/react';`);
        const isOther = !isSVG && !isTest;
        const usesStyledComponents = -1 !== fileContent.indexOf(`from 'styled-components';`);
        const usesPimShared = -1 !== fileContent.indexOf(`from '@akeneo-pim-community/shared';`);
        const usesLegacyBridge = -1 !== fileContent.indexOf(`from '@akeneo-pim-community/legacy-bridge';`);
        const usesDSM = -1 !== fileContent.indexOf(`from 'akeneo-design-system';`);

        resolve({isSVG, isTest, isOther, usesStyledComponents, usesPimShared, usesLegacyBridge, usesDSM})
      }
    });
  })
}

const compileMetrics = (metrics) => {
  return metrics.reduce((result, metric) => (
    Object.keys(metric).reduce((newMetric, key) => ({
      ...result,
      ...newMetric,
      [key]: metric[key] ? result[key] + 1 : result[key],
    }), {})
  ), {
    total: metrics.length,
    isSVG: 0,
    isTest: 0,
    isOther: 0,
    usesStyledComponents: 0,
    usesPimShared: 0,
    usesLegacyBridge: 0,
    usesDSM: 0,
  });




  // ({
  //   isSVG: metric.isSVG ? result.isSVG + 1 : result.isSVG,
  //   isTest: metric.isTest ? result.isTest + 1 : result.isTest,
  //   usesStyledComponents: metric.usesStyledComponents ? result.usesStyledComponents + 1 : result.usesStyledComponents,
  //   usesPimShared: metric.usesPimShared ? result.usesPimShared + 1 : result.usesPimShared,
  //   usesLegacyBridge: metric.usesLegacyBridge ? result.usesLegacyBridge + 1 : result.usesLegacyBridge,
  // }), {isSVG: 0, isTest: 0, usesStyledComponents: 0, usesPimShared: 0, usesLegacyBridge: 0})
}

(async () => {
  try {
    switch (commandName[0]) {
      case 'generate':
        await copyComponentFolder('generator/components/MyComponent', `src/components/${ComponentName}`);
        await renameComponentFolder('MyComponent', ComponentName);
        exportComponentToIndex('src/components/index.ts', ComponentName);
        break;
      case 'metric':
        const files = await getTsxFiles(sourceFolder);
        const metrics = [];
        for (const file of files) {
          metrics.push(await getFileMetrics(file));
        }

        console.log(compileMetrics(metrics));

        break;

      default:
        break;
    }
  } catch (e) {
    console.error(e);
  }
})();
